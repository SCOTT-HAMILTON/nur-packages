Seulement dans src-working-icons: override_drun_search_dirs.patch
Seulement dans src-working-icons: ..rej
diff -ur b/source/dialogs/drun.c src-working-icons/source/dialogs/drun.c
--- b/source/dialogs/drun.c	2020-07-04 22:31:45.725085138 +0200
+++ src-working-icons/source/dialogs/drun.c	2020-07-04 22:31:36.889983343 +0200
@@ -589,6 +589,19 @@
 {
     TICK_N ( "Get Desktop apps (start)" );
 
+	{
+		const gchar* nix_profiles = g_getenv("NIX_PROFILES");
+		gchar** nix_profiles_list = g_strsplit(nix_profiles, " ", -1);
+		int i = 0;
+		gchar* current_profile_dir = nix_profiles_list[0];
+		for (i = 0; current_profile_dir != NULL; current_profile_dir = nix_profiles_list[++i]) {
+			gchar* dir = g_build_filename(current_profile_dir, "share", "applications", NULL);
+			walk_dir ( pd, dir, dir );
+			g_free ( dir );
+		}
+		g_strfreev(nix_profiles_list);
+	}
+
     gchar *dir;
     // First read the user directory.
     dir = g_build_filename ( g_get_user_data_dir (), "applications", NULL );
@@ -802,11 +815,15 @@
     g_return_val_if_fail ( pd->entry_list != NULL, NULL );
     DRunModeEntry       *dr = &( pd->entry_list[selected_line] );
     if ( dr->icon_name == NULL ) {
+		fprintf(stderr, "No filename\n");
         return NULL;
     }
     if ( dr->icon_fetch_uid > 0 ) {
+		fprintf(stderr, "No uid\n");
         return rofi_icon_fetcher_get ( dr->icon_fetch_uid );
     }
+	fprintf(stderr, "filename : `%s`\n", dr->icon_name);
+
     dr->icon_fetch_uid = rofi_icon_fetcher_query ( dr->icon_name, height );
     return rofi_icon_fetcher_get ( dr->icon_fetch_uid );
 }
diff -ur b/source/rofi-icon-fetcher.c src-working-icons/source/rofi-icon-fetcher.c
--- b/source/rofi-icon-fetcher.c	2020-07-04 22:31:45.724085127 +0200
+++ src-working-icons/source/rofi-icon-fetcher.c	2020-07-04 22:31:36.887983320 +0200
@@ -103,6 +103,7 @@
     static const gchar * const icon_fallback_themes[] = {
         "Adwaita",
         "gnome",
+		"hicolor",
         NULL
     };
     const char                 *themes[2] = { config.icon_theme, NULL };
@@ -131,6 +132,7 @@
 }
 static void rofi_icon_fetcher_worker ( thread_state *sdata, G_GNUC_UNUSED gpointer user_data )
 {
+	fprintf(stderr, "starting icon fetching worked\n");
     g_debug ( "starting up icon fetching thread." );
     // as long as dr->icon is updated atomicly.. (is a pointer write atomic?)
     // this should be fine running in another thread.
@@ -192,9 +194,11 @@
     for ( GList *iter = g_list_first ( entry->sizes ); iter; iter = g_list_next ( iter ) ) {
         sentry = iter->data;
         if ( sentry->size == size ) {
+			fprintf(stderr, "found in icon cache");
             return sentry->uid;
         }
     }
+	fprintf(stderr, "not found in icon cache");
 
     // Not found.
     sentry          = g_new0 ( IconFetcherEntry, 1 );
diff -ur b/subprojects/libnkutils/src/xdg-theme.c src-working-icons/subprojects/libnkutils/src/xdg-theme.c
--- b/subprojects/libnkutils/src/xdg-theme.c	2020-07-04 22:33:55.474573270 +0200
+++ src-working-icons/subprojects/libnkutils/src/xdg-theme.c	2020-07-04 22:31:36.883983274 +0200
@@ -316,18 +316,20 @@
 
     try_dir(g_get_user_data_dir());
 
-	 {    
-		const gchar* nix_profiles = g_getenv("NIX_PROFILES");
-		gchar** nix_profiles_list = g_strsplit(nix_profiles, " ", -1); 
-		int i = 0; 
-		gchar* current_profile_dir = nix_profiles_list[0];
-		for (i = 0; current_profile_dir != NULL; current_profile_dir = nix_profiles_list[++i]) {
+	// Nix-profiles user dir
+	/* fprintf(stderr, "subdir : %s\n", subdir); */
+	{
+        const gchar* nix_profiles = g_getenv("NIX_PROFILES");
+        gchar** nix_profiles_list = g_strsplit(nix_profiles, " ", -1);
+        int i = 0;
+        gchar* current_profile_dir = nix_profiles_list[0];
+        for (i = 0; current_profile_dir != NULL; current_profile_dir = nix_profiles_list[++i]) {
 			gchar* dir = g_build_filename(current_profile_dir, "share", NULL);
 			try_dir(dir);
 			fprintf(stderr, "dir  : %s\n", dir);
 			g_free ( dir );
-		}    
-		g_strfreev(nix_profiles_list);
+        }
+        g_strfreev(nix_profiles_list);
 	}
 
     switch ( self->type )
@@ -748,38 +750,55 @@
 static gboolean
 _nk_xdg_theme_foreach_theme(NkXdgThemeTypeContext *self, const gchar * const *theme_names, const gchar *fallback_theme,  NkXdgThemeForeachCallback callback, gconstpointer data, gpointer *ret)
 {
+
+	fprintf(stderr, "foreach theme\n");
     NkXdgThemeTheme *theme;
 
     const gchar * const *theme_name;
     for ( theme_name = theme_names ; *theme_name != NULL ; ++theme_name )
     {
         theme = _nk_xdg_theme_get_theme(self, *theme_name);
-        if ( ( theme != NULL ) && callback(theme, data, ret) )
+		fprintf(stderr, "theme name %s is NULL %d\n", *theme_name, theme == NULL);
+        if ( ( theme != NULL ) && callback(theme, data, ret) ) {
+			fprintf(stderr, "FOUND in theme\n");
             return TRUE;
+		}
     }
+	fprintf(stderr, "foreach theme de_theme == NULL : %d\n", self->de_theme == NULL);
 
     if ( self->de_theme != NULL )
     {
         theme = _nk_xdg_theme_get_theme(self, self->de_theme);
-        if ( ( theme != NULL ) && callback(theme, data, ret) )
+		fprintf(stderr, "theme de is NULL %d\n", theme == NULL);
+        if ( ( theme != NULL ) && callback(theme, data, ret) ) {
+			fprintf(stderr, "FOUND in theme\n");
             return TRUE;
+		}
     }
 
+	fprintf(stderr, "foreach theme gtk_theme == NULL : %d\n", self->gtk_theme == NULL);
     if ( self->gtk_theme != NULL )
     {
         theme = _nk_xdg_theme_get_theme(self, self->gtk_theme);
-        if ( ( theme != NULL ) && callback(theme, data, ret) )
+		fprintf(stderr, "gtk theme is NULL %d\n", theme == NULL);
+        if ( ( theme != NULL ) && callback(theme, data, ret) ) {
+			fprintf(stderr, "FOUND in gtk theme\n");
             return TRUE;
+		}
     }
 
     for ( theme_name = self->fallback_themes ; *theme_name != NULL ; ++theme_name )
     {
         theme = _nk_xdg_theme_get_theme(self, *theme_name);
-        if ( ( theme != NULL ) && callback(theme, data, ret) )
+		fprintf(stderr, "fallbacktheme %s  == NULL : %d\n", *theme_name, theme == NULL);
+        if ( ( theme != NULL ) && callback(theme, data, ret) ) {
+			fprintf(stderr, "FOUND in falleback theme %s\n", *theme_name);
             return TRUE;
+		}
     }
 
     theme = _nk_xdg_theme_get_theme(self, fallback_theme);
+	fprintf(stderr, "last fallbacktheme %s  == NULL : %d\n", fallback_theme, theme == NULL);
     if ( ( theme != NULL ) && callback(theme, data, ret) )
         return TRUE;
 
@@ -978,6 +997,7 @@
 gchar *
 nk_xdg_theme_get_icon(NkXdgThemeContext *context, const gchar * const *theme_names, const gchar *context_name, const gchar *name, gint size, gint scale, gboolean svg)
 {
+	fprintf(stderr, "Get icon from xdg theme\n");
     g_return_val_if_fail(context != NULL, NULL);
     g_return_val_if_fail(name != NULL, NULL);
     g_return_val_if_fail(scale > 0, NULL);
@@ -999,12 +1019,16 @@
     gchar *file;
     const gchar *names[] = { name, NULL };
 
+	fprintf(stderr, "Searching file in themes\n");
     file = _nk_xdg_theme_search_file(self, names, theme_names, NK_XDG_THEME_ICON_FALLBACK_THEME, _nk_xdg_theme_icon_find_file, &data, data.extensions);
-    if ( file != NULL )
+	fprintf(stderr, "name : %s\n", name);
+    if ( file != NULL ) {
+		fprintf(stderr, "\nFound in themes : %s\n\n", file);
         return file;
-
+	}
     if ( symbolic )
     {
+		fprintf(stderr, "symbolic\n");
         gchar *no_symbolic_name;
         gsize l;
         l = strlen(name) - strlen("-symbolic") + 1;
@@ -1012,6 +1036,7 @@
         g_snprintf(no_symbolic_name, l, "%s", name);
         return nk_xdg_theme_get_icon(context, theme_names, context_name, no_symbolic_name, size, scale, svg);
     }
+	fprintf(stderr, "not symbolic\n");
 
     return NULL;
 }
